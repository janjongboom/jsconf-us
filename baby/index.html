<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Baby Thing</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
    }

    body {
      background: black;
      font-family: 'Open Sans', sans-serif;
      color: white;
    }

    h1 {
      text-align: left;
      font-weight: 300;
      margin: 20px 20px;
    }
    
    canvas {
      position: absolute;
      top: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
    }
  </style>
</head>
<body>
  <h1 style="font-size: 60px">Baby Trackr 2000</h1>
  <ul id="beacons"></ul>
  
  <canvas id="trackr"></canvas>

  <script>
  
  var cvs = document.querySelector('#trackr');
  var ctx = cvs.getContext('2d');
  var pixelPerMm = 1;
  // in meters
  var DISTANCE_BETWEEN_BEACONS = 5.00;
  
  window.onresize = () => {
    vw = window.innerWidth;
    vh = window.innerHeight;
    
    cvs.width = vw;
    cvs.height = vh;
  };
  window.onresize();
  
  var distance = {
    ice: 1,
    mint: 1,
    blueberry: 1
  };
  
  function calcDistance(rssi) {
    var MEASURED_RSSI = 85;
    var MEASURED_DISTANCE = 5;
    
    
    
    
    var txPower = -70;
    if (rssi === 0) {
      return -1.0;
    }
  
    var ratio = rssi * 1.0 / txPower;
    if (ratio < 1.0) {
      return Math.pow(ratio, 10);
    }
    else {
      var accuracy =  (0.89976) * Math.pow(ratio, 7.7095) + 0.111;    
      return accuracy;
    }
  }
  
  function drawSomething() {
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    
    var distanceInPx = DISTANCE_BETWEEN_BEACONS * pixelPerMm * 100;

    var iceX = 300, 
        iceY = 300;
    
    var blueberryX = iceX + distanceInPx,
        blueberryY = iceY;
    
    var mintX = iceX,
        mintY = iceY + distanceInPx;
    
    ctx.lineWidth = 2;
    drawBeacon('#b0e2ff', iceX, iceY, distance.ice);
    drawBeacon('#b4d7bf', mintX, mintY, distance.mint);
    drawBeacon('#4100c2', blueberryX, blueberryY, distance.blueberry);
    
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 5;
    
    line(iceX, iceY + 20, mintX, mintY - 20);
    line(iceX + 20, iceY, blueberryX - 20, blueberryY);
    line(mintX + 20, mintY, mintX + distanceInPx, mintY);
    line(blueberryX, blueberryY + 20, blueberryX, blueberryY + distanceInPx);
  }
  
  function line(x, y, endX, endY) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
  }
  
  function drawBeacon(color, x, y, distance) {
    distance = distance * pixelPerMm * 100 | 0;
    
    ctx.fillStyle = ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI*2, true); 
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.arc(x, y, distance, 0, Math.PI*2, true); 
    ctx.closePath();
    ctx.stroke();
  }
  
  drawSomething();
  
  
  function intersection(x0, y0, r0, x1, y1, r1) {
    var a, dx, dy, d, h, rx, ry;
    var x2, y2;

    /* dx and dy are the vertical and horizontal distances between
     * the circle centers.
     */
    dx = x1 - x0;
    dy = y1 - y0;

    /* Determine the straight-line distance between the centers. */
    d = Math.sqrt((dy*dy) + (dx*dx));

    /* Check for solvability. */
    if (d > (r0 + r1)) {
        /* no solution. circles do not intersect. */
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        /* no solution. one circle is contained in the other */
        return false;
    }

    /* 'point 2' is the point where the line through the circle
     * intersection points crosses the line between the circle
     * centers.  
     */

    /* Determine the distance from point 0 to point 2. */
    a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;

    /* Determine the coordinates of point 2. */
    x2 = x0 + (dx * a/d);
    y2 = y0 + (dy * a/d);

    /* Determine the distance from point 2 to either of the
     * intersection points.
     */
    h = Math.sqrt((r0*r0) - (a*a));

    /* Now determine the offsets of the intersection points from
     * point 2.
     */
    rx = -dy * (h/d);
    ry = dx * (h/d);

    /* Determine the absolute intersection points. */
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return [xi, xi_prime, yi, yi_prime];
  }
  
  
  
  var wsOpen = false;
  var ws;
  function connect() {
    ws = new WebSocket('ws://' + location.hostname + ':9322');
    ws.onopen = function() {
      wsOpen = true;
    };
    ws.onclose = function() {
      document.querySelector('#beacons').innerHTML = '';

      wsOpen = false;
      connect();
    };
    ws.onmessage = function(e) {
      var data = e.data;
      if (typeof data === 'string') data = JSON.parse(data);
      
      if (data.type === 'beacon') {
        var beacon = data;
        var ele = document.querySelector('li[data-major="' + beacon.major + '"]');
        if (!ele) {
          ele = document.createElement('li');
          ele.dataset.major = beacon.major;
          document.querySelector('#beacons').appendChild(ele);
        }
        
        var d = calcDistance(beacon.avgRssi);
        
        ele.textContent = beacon.name + ' (' + d.toFixed(2) + 'm)';
        
        distance[beacon.name] = d;
        
        drawSomething();
      }
    };
  }
  connect();

  </script>
</body>
</html>
