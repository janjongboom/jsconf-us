{"_id":"gibber/publications/SpeakLib","_rev":"7-e0453f9981a742f278c94dda527b67a3","name":"SpeakLib","author":"gibber","type":"publication","publicationDate":["2015","1","20","22:02:12"],"text":"!function() {\n module('gibber/publications/Speak_config').done( function( _config ) {\n config = _config\n console.log(\"Speak Config loaded. Now loading Speak voice file.\")\n module('gibber/publications/Speak_voice').done( function( _voice ) {\n voice = _voice\n console.log(\"Speak Voice loaded. Now loading the meSpeak library (last one!)\")\n $.get(\n Gibber.Environment.SERVER_URL + '/gibber/gibber/publications/Speak', {},\n function( d ) {\n console.log(\"meSpeak loaded. Speak is now ready\")\n /* \n To make this work, we download the text comprising the meSpeak library, \n and pass it into our web worker. The first time the web worker runs,\n the mespeak library text is evaluted and initialized. Subsequent calls\n will not re-initalize the libarary or set configurations.\n */\n var obj = JSON.parse( d )\n onmessage = function( e ) {\n var\t_text = e.data[0],\n _options = e.data[1],\n meSpeakText = e.data[2],\n _configText = e.data[3],\n _voiceText = e.data[4]\n\n if( meSpeakText && typeof meSpeak === 'undefined' ) {\n eval( meSpeakText )\n }\n if( meSpeak && _configText && typeof _config === 'undefined' ) {\n meSpeak.setConfigData( _configText )\n _config = true\n }\n if( meSpeak && _voiceText && typeof _voice === 'undefined' ) {\n meSpeak.setVoiceData( _voiceText )\n _voice = true\n }\n var buffer = meSpeak.speak( _text, _options )\n postMessage( buffer )\n }\n \n var workerSetTextString = \"onmessage = \" + onmessage.toString(),\n workerBlob = new Blob([ workerSetTextString ], { type:'text/javascript'})\n myworker = new Worker( window.URL.createObjectURL( workerBlob ) )\n \n Speak = function() {\n var sampler = Gibber.Audio.Samplers.Sampler(),\n initialized = false\n\n sampler.setText = function( text, options, onload ) {\n sampler.file = text\n if( !options ) {\n options = { rawdata:true }\n }else{\n options.rawdata = true\n }\n\n if( !sampler.buffers[ text ] ) {\n myworker.onmessage = function( e ) {\n var buffer = e.data\n Gibber.Audio.Core.context.decodeAudioData( buffer, function( _buffer ) {\n sampler._onload( { channels: [ _buffer.getChannelData( 0 ) ], 'length':_buffer.length } )\n if( onload ) onload()\n })\n }\n if( !initialized ) {\n myworker.postMessage( [ text, options, obj.text, config, voice ] )\n }else{\n myworker.postMessage( [ text, options, obj.text ] )\n }\n }else{\n sampler.switchBuffer( text )\n }\n\n return sampler\n }\n\n sampler.say = function( text, speed, options ) {\n if( ! sampler.buffers[ text ] ) {\n sampler.setText( text, options, function() { sampler.note( speed ); })\n }else{\n sampler.switchBuffer( text )\n sampler.note( speed )\n }\n\n return sampler\n }\n\n Gibber.defineSequencedProperty( sampler, 'say', true )\n\n return sampler\n }\n })\n \n //Speak.meSpeak = meSpeak\n \n //return Speak\n })\n })\n}()","tags":["speech"," Speak"," Sampler"],"permissions":"true","isInstrument":"false","notes":"Library for using Speak object, Gibber's text-to-speech option.","revisionNotes":""} 